<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/997bb99dff39a320.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-695d994ee6bbb75a.js"/><script src="/_next/static/chunks/3f5966fd-da022534e16ddcac.js" async=""></script><script src="/_next/static/chunks/313-804dc18f7265100e.js" async=""></script><script src="/_next/static/chunks/main-app-165d6d8e388c7c9d.js" async=""></script><script src="/_next/static/chunks/18-a08db35d0c492fb3.js" async=""></script><script src="/_next/static/chunks/802-8624e27f06c26e64.js" async=""></script><script src="/_next/static/chunks/app/posts/%5Bslug%5D/page-113a3a94ad4fe476.js" async=""></script><title>You might not need thunk | naturalclar.dev</title><meta name="description" content="
状態管理に redux を使っている人は以下の様なことをやりたいことがあるでしょう。

- ログイン処理でフォームを Submit した時に API を叩いて、返ってきた Auth 情報を store に保持する。
- ページを開いた時に API を叩いて、返ってきた Response を store に保持する。

このような非同期処理の結果を redux に保持することが必要な時にはよく `..."/><meta name="author" content="Naturalclar (Jesse Katsumata)"/><meta name="keywords" content="react, react-native, nextjs, blog"/><meta name="creator" content="Naturalclar (Jesse Katsumata)"/><meta name="publisher" content="Naturalclar (Jesse Katsumata)"/><meta name="robots" content="index, follow"/><meta property="og:title" content="You might not need thunk | naturalclar.dev"/><meta property="og:description" content="
状態管理に redux を使っている人は以下の様なことをやりたいことがあるでしょう。

- ログイン処理でフォームを Submit した時に API を叩いて、返ってきた Auth 情報を store に保持する。
- ページを開いた時に API を叩いて、返ってきた Response を store に保持する。

このような非同期処理の結果を redux に保持することが必要な時にはよく `..."/><meta property="og:url" content="https://blog.naturalclar.dev/"/><meta property="og:site_name" content="naturalclar.dev"/><meta property="og:image" content="https://blog.naturalclar.dev/twitter-card.png"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="You might not need thunk"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:creator" content="@natural_clar"/><meta name="twitter:title" content="You might not need thunk | naturalclar.dev"/><meta name="twitter:description" content="
状態管理に redux を使っている人は以下の様なことをやりたいことがあるでしょう。

- ログイン処理でフォームを Submit した時に API を叩いて、返ってきた Auth 情報を store に保持する。
- ページを開いた時に API を叩いて、返ってきた Response を store に保持する。

このような非同期処理の結果を redux に保持することが必要な時にはよく `..."/><meta name="twitter:image" content="https://blog.naturalclar.dev/twitter-card.png"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div style="margin-left:auto;margin-right:auto;max-width:680px;padding:24px 12px"><h3 style="font-family:Montserrat, sans-serif;margin-top:0"><a style="box-shadow:none;text-decoration:none;color:inherit" href="/">naturalclar.dev</a></h3><h1>You might not need thunk</h1><p style="display:block;margin-bottom:16px">September 01, 2019</p><div><p>状態管理に redux を使っている人は以下の様なことをやりたいことがあるでしょう。</p>
<ul>
<li>ログイン処理でフォームを Submit した時に API を叩いて、返ってきた Auth 情報を store に保持する。</li>
<li>ページを開いた時に API を叩いて、返ってきた Response を store に保持する。</li>
</ul>
<p>このような非同期処理の結果を redux に保持することが必要な時にはよく <code>redux-thunk</code>, または <code>redux-saga</code>が採用されていた。
今回は非同期処理に thunk も saga も使う必要なくなったのでは？と言う話です。</p>
<p>なお、筆者は redux-saga についてはそこまで使ったことが無いので、この記事では主に<code>redux-thunk</code>のリプレイスについて書きます。</p>
<h2>tl;dr;</h2>
<ul>
<li>react-redux の hooks api を用いて custom hooks に非同期処理を入れる。</li>
<li>redux で保持するべきはユーザが必要な情報（Loading は要らない）</li>
<li>ロジックはすべて custom hooks に閉じ込めよう。</li>
</ul>
<h2>redux-thunk の流れ</h2>
<p>redux-thunk で非同期処理の流れを簡単に書くと：</p>
<ul>
<li>非同期処理を始める前に、画面に「読み込み中‥」などを表示させるために、Loading 状態にする</li>
<li>非同期処理を始める。</li>
<li>非同期処理が無事終わったら、結果を store に反映させ、Loading 状態を外す</li>
<li>非同期処理に何らかの問題が発生したら、その旨を表示させ、Loading 状態を外す</li>
</ul>
<p>となります。</p>
<p>コードで書くとこういう感じです：</p>
<p><code>fooReducer.ts</code></p>
<pre><code class="language-js">
type FooState = {
  loadng: boolean,
  list: Item[],
  error: stirng
}

const initialState:FooState  = {
  loading: false,
  list: [],
  error: string
}

export const fooReducer = (state:FooState = initialState, action:FooAction) => {
  switch(action.type) {
    case: 'FOO_START':
      return { ...state, loading: true}
    case: 'FOO_SUCCESS':
      return { ...state, loading: false, list: action.result}
    case: 'FOO_FAILED':
      return { ...state, loading: false, error: action.error}
    default:
      return state;
  }
}
</code></pre>
<p><code>fooAction.ts</code></p>
<pre><code class="language-js">export const fooAction = (): ThunkAction => async (dispatch: Dispatch) => {
  // 非同期処理を開始するため、状態をLoadingにする
  dispatch({ type: 'FOO_START' })
  // 非同期処理を行う
  try {
    const result = await fetch('/getFoo')
    // 成功したら結果をreduxに反映し、Loading状態を外す
    dispatch({ type: 'FOO_SUCCESS', result })
  } catch (e) {
    // エラーが発生したらエラーメッセージを表示させ、Loading状態を外す
    console.error(e)
    dispatch({ type: 'FOO_FAILED', error: e.message })
  }
}
</code></pre>
<h2>redux-thunk のつらみ</h2>
<p>上記の通り、redux-thunk がやっていること自体は単純なのですが、
それを書くのに結構な量のコードを書く必要があります。
上記に加えて、store の状態をもとに処理を分岐させる必要がある場合、thunk 内で getState を呼んだりと、処理が複雑化してきます。</p>
<p>筆者が感じる Issue としては以下のようなことがあります：</p>
<ul>
<li><code>STARTED</code>, <code>SUCCESS</code>, <code>FAILED</code> の 3 つの Action を書く必要があった。</li>
<li><code>Loading</code>の状態を reducer で持つ必要があった。</li>
<li>非同期処理が行われる度に別々の Loading を書く必要があった。
1 画面で複数の非同期処理が走る際、</li>
</ul>
<p>つまりやりたいことは：</p>
<ul>
<li>Action の発火は必要な状態が変わる一回に済ませたい。</li>
<li>Loading は redux 外で管理したい。</li>
<li>非同期処理の共通部分を使いまわしたい。</li>
</ul>
<h2>解決案</h2>
<p>react の custom hooks を使えば解決します。
react-redux の v7.1 から、hooks に対応した API が出たのでそれらを使っていきます。</p>
<p>上で書いた redux-thunk の例を custom hooks を使って簡略化することができます。</p>
<p>以下のことをやっていきます。</p>
<ul>
<li>loading は useState で保持して、hooks 内で完結させる。</li>
<li>dispatch を使うのは、非同期処理が終わってからの一回のみで済ませる。</li>
</ul>
<p><code>useFoo.ts</code></p>
<pre><code class="language-js">import { useState, useCallback } form 'react'
import { useSelector, useDispatch } from 'react-redux'
import { State, FooAction } from './types'

export const useFoo = () => {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')
  const items = useSelector((state:State)=> state.foo.items)
  const dispatch = useDispatch&#x3C;Dispatch&#x3C;FooAction>>()

  const getFoo = useCallback(async () => {
    setLoading(true)
    try {
    const result = await fetch('/getFoo')
        setLoading(false)
        dispatch({type: 'FOO_SUCCESS', result})
    } catch (e) {
        setLoading(false)
        setError(e.message)
      }
    },[loading, error, items])

  return [items, getFoo, loading, error]
}

</code></pre>
<p>loading と error を持つ必要がなくなったので、reducer も簡略化することができます。</p>
<p><code>fooReducer.ts</code></p>
<pre><code class="language-js">
type FooState = {
  list: Item[],
}

const initialState:FooState  = {
  list: [],
}

export const fooReducer = (state:FooState = initialState, action:FooAction) => {
  switch(action.type) {
    case: 'FOO_SUCCESS':
      return { ...state, list: action.result}
    default:
      return state;
  }
}
</code></pre>
<p>component での使用例はこんな感じです</p>
<p><code>FooList.tsx</code></p>
<pre><code class="language-js">import React, { useEffect } from 'react'
import { useFoo } from './useFoo'

export const FooList = () => {
  const [items, getFoo, loading, error] = useFoo()
  useEffect(() => {
    getFoo()
  }, [])

  if (loading) {
    return &#x3C;p>読込中…&#x3C;/p>
  }

  return (
    &#x3C;div>
      {error ? &#x3C;p>{error}&#x3C;/p> : null}
      &#x3C;ul>
        {items.map((item) => {
          return &#x3C;li>{item.contents}&#x3C;/li>
        })}
      &#x3C;/ul>
    &#x3C;/div>
  )
}
</code></pre>
<p>このような形で、ページ遷移時に非同期で何かを取得してくる処理を thunk 無しでも実現することができます。</p>
<p>また、このように非同期処理のロジックを custom hooks に閉じ込めておくことで、別のページで同じ処理が必要になった時に hooks を使い回すことができます
上の Compnent の例では、useEffect も useFoo の中に入れることで、完全にロジックと Component を分割させることができます。</p>
<h2>あとがき</h2>
<p>これはあくまで自分の redux-thunk の使い方なら redux-thunk 使わなくても出来るかなと言う話なので、
redux-thunk や redux-saga じゃないとこれができないよ！みたいなことがあれば教えてほしいです。</p>
</div><hr style="margin-bottom:16px"/><div style="display:flex;align-items:center;margin-bottom:40px"><img alt="Naturalclar (Jesse Katsumata)" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" style="color:transparent;margin-right:16px;margin-bottom:0;min-width:50px;border-radius:100%" src="https://www.github.com/Naturalclar.png"/><div style="display:flex;flex-direction:column;gap:8px"><p style="margin:0">Author: <strong>Naturalclar (Jesse Katsumata)</strong></p><p style="margin:0"><a href="https://x.com/natural_clar">X</a> <a href="https://www.github.com/Naturalclar">Github</a></p></div></div><ul style="display:flex;flex-wrap:wrap;justify-content:space-between;list-style:none;padding:0"><li><a rel="prev" href="/posts/typescript-allowing-unused-param/">← <!-- -->noUnusedParametersがtrueでも部分的にignoreできる話</a></li><li><a rel="next" href="/posts/chrome-devtool-console/">Chrome Developer ToolsのConsole<!-- --> →</a></li></ul><footer>© <!-- -->2025<!-- -->, Built with<!-- --> <a href="https://nextjs.org">Next.js</a></footer></div><script src="/_next/static/chunks/webpack-695d994ee6bbb75a.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/997bb99dff39a320.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[8493,[],\"\"]\n5:I[3754,[],\"\"]\n7:I[7754,[],\"\"]\n8:I[7574,[\"18\",\"static/chunks/18-a08db35d0c492fb3.js\",\"802\",\"static/chunks/802-8624e27f06c26e64.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-113a3a94ad4fe476.js\"],\"default\"]\n9:I[8750,[\"18\",\"static/chunks/18-a08db35d0c492fb3.js\",\"802\",\"static/chunks/802-8624e27f06c26e64.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-113a3a94ad4fe476.js\"],\"\"]\nb:I[253,[],\"\"]\n6:[\"slug\",\"you-might-not-need-thunk\",\"d\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"bVXrX63nls6mz3NDAu0w6\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"posts\",\"you-might-not-need-thunk\",\"\"],\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"you-might-not-need-thunk\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"you-might-not-need-thunk\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"you-might-not-need-thunk\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/997bb99dff39a320.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"$L8\",null,{\"title\":\"naturalclar.dev\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"404 - Page Not Found\"}],[\"$\",\"p\",null,{\"children\":\"You just hit a route that doesn't exist... the sadness.\"}],[\"$\",\"p\",null,{\"children\":[\"$\",\"$L9\",null,{\"href\":\"/\",\"children\":\"Go back to the homepage\"}]}]]}],\"notFoundStyles\":[]}]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"e:I[4802,[\"18\",\"static/chunks/18-a08db35d0c492fb3.js\",\"802\",\"static/chunks/802-8624e27f06c26e64.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-113a3a94ad4fe476.js\"],\"Image\"]\nd:T1cf2,"])</script><script>self.__next_f.push([1,"\u003cp\u003e状態管理に redux を使っている人は以下の様なことをやりたいことがあるでしょう。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eログイン処理でフォームを Submit した時に API を叩いて、返ってきた Auth 情報を store に保持する。\u003c/li\u003e\n\u003cli\u003eページを開いた時に API を叩いて、返ってきた Response を store に保持する。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eこのような非同期処理の結果を redux に保持することが必要な時にはよく \u003ccode\u003eredux-thunk\u003c/code\u003e, または \u003ccode\u003eredux-saga\u003c/code\u003eが採用されていた。\n今回は非同期処理に thunk も saga も使う必要なくなったのでは？と言う話です。\u003c/p\u003e\n\u003cp\u003eなお、筆者は redux-saga についてはそこまで使ったことが無いので、この記事では主に\u003ccode\u003eredux-thunk\u003c/code\u003eのリプレイスについて書きます。\u003c/p\u003e\n\u003ch2\u003etl;dr;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ereact-redux の hooks api を用いて custom hooks に非同期処理を入れる。\u003c/li\u003e\n\u003cli\u003eredux で保持するべきはユーザが必要な情報（Loading は要らない）\u003c/li\u003e\n\u003cli\u003eロジックはすべて custom hooks に閉じ込めよう。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eredux-thunk の流れ\u003c/h2\u003e\n\u003cp\u003eredux-thunk で非同期処理の流れを簡単に書くと：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e非同期処理を始める前に、画面に「読み込み中‥」などを表示させるために、Loading 状態にする\u003c/li\u003e\n\u003cli\u003e非同期処理を始める。\u003c/li\u003e\n\u003cli\u003e非同期処理が無事終わったら、結果を store に反映させ、Loading 状態を外す\u003c/li\u003e\n\u003cli\u003e非同期処理に何らかの問題が発生したら、その旨を表示させ、Loading 状態を外す\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eとなります。\u003c/p\u003e\n\u003cp\u003eコードで書くとこういう感じです：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efooReducer.ts\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\ntype FooState = {\n  loadng: boolean,\n  list: Item[],\n  error: stirng\n}\n\nconst initialState:FooState  = {\n  loading: false,\n  list: [],\n  error: string\n}\n\nexport const fooReducer = (state:FooState = initialState, action:FooAction) =\u003e {\n  switch(action.type) {\n    case: 'FOO_START':\n      return { ...state, loading: true}\n    case: 'FOO_SUCCESS':\n      return { ...state, loading: false, list: action.result}\n    case: 'FOO_FAILED':\n      return { ...state, loading: false, error: action.error}\n    default:\n      return state;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efooAction.ts\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eexport const fooAction = (): ThunkAction =\u003e async (dispatch: Dispatch) =\u003e {\n  // 非同期処理を開始するため、状態をLoadingにする\n  dispatch({ type: 'FOO_START' })\n  // 非同期処理を行う\n  try {\n    const result = await fetch('/getFoo')\n    // 成功したら結果をreduxに反映し、Loading状態を外す\n    dispatch({ type: 'FOO_SUCCESS', result })\n  } catch (e) {\n    // エラーが発生したらエラーメッセージを表示させ、Loading状態を外す\n    console.error(e)\n    dispatch({ type: 'FOO_FAILED', error: e.message })\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eredux-thunk のつらみ\u003c/h2\u003e\n\u003cp\u003e上記の通り、redux-thunk がやっていること自体は単純なのですが、\nそれを書くのに結構な量のコードを書く必要があります。\n上記に加えて、store の状態をもとに処理を分岐させる必要がある場合、thunk 内で getState を呼んだりと、処理が複雑化してきます。\u003c/p\u003e\n\u003cp\u003e筆者が感じる Issue としては以下のようなことがあります：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSTARTED\u003c/code\u003e, \u003ccode\u003eSUCCESS\u003c/code\u003e, \u003ccode\u003eFAILED\u003c/code\u003e の 3 つの Action を書く必要があった。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLoading\u003c/code\u003eの状態を reducer で持つ必要があった。\u003c/li\u003e\n\u003cli\u003e非同期処理が行われる度に別々の Loading を書く必要があった。\n1 画面で複数の非同期処理が走る際、\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eつまりやりたいことは：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAction の発火は必要な状態が変わる一回に済ませたい。\u003c/li\u003e\n\u003cli\u003eLoading は redux 外で管理したい。\u003c/li\u003e\n\u003cli\u003e非同期処理の共通部分を使いまわしたい。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e解決案\u003c/h2\u003e\n\u003cp\u003ereact の custom hooks を使えば解決します。\nreact-redux の v7.1 から、hooks に対応した API が出たのでそれらを使っていきます。\u003c/p\u003e\n\u003cp\u003e上で書いた redux-thunk の例を custom hooks を使って簡略化することができます。\u003c/p\u003e\n\u003cp\u003e以下のことをやっていきます。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eloading は useState で保持して、hooks 内で完結させる。\u003c/li\u003e\n\u003cli\u003edispatch を使うのは、非同期処理が終わってからの一回のみで済ませる。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003euseFoo.ts\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport { useState, useCallback } form 'react'\nimport { useSelector, useDispatch } from 'react-redux'\nimport { State, FooAction } from './types'\n\nexport const useFoo = () =\u003e {\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState('')\n  const items = useSelector((state:State)=\u003e state.foo.items)\n  const dispatch = useDispatch\u0026#x3C;Dispatch\u0026#x3C;FooAction\u003e\u003e()\n\n  const getFoo = useCallback(async () =\u003e {\n    setLoading(true)\n    try {\n    const result = await fetch('/getFoo')\n        setLoading(false)\n        dispatch({type: 'FOO_SUCCESS', result})\n    } catch (e) {\n        setLoading(false)\n        setError(e.message)\n      }\n    },[loading, error, items])\n\n  return [items, getFoo, loading, error]\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eloading と error を持つ必要がなくなったので、reducer も簡略化することができます。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efooReducer.ts\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\ntype FooState = {\n  list: Item[],\n}\n\nconst initialState:FooState  = {\n  list: [],\n}\n\nexport const fooReducer = (state:FooState = initialState, action:FooAction) =\u003e {\n  switch(action.type) {\n    case: 'FOO_SUCCESS':\n      return { ...state, list: action.result}\n    default:\n      return state;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecomponent での使用例はこんな感じです\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eFooList.tsx\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport React, { useEffect } from 'react'\nimport { useFoo } from './useFoo'\n\nexport const FooList = () =\u003e {\n  const [items, getFoo, loading, error] = useFoo()\n  useEffect(() =\u003e {\n    getFoo()\n  }, [])\n\n  if (loading) {\n    return \u0026#x3C;p\u003e読込中…\u0026#x3C;/p\u003e\n  }\n\n  return (\n    \u0026#x3C;div\u003e\n      {error ? \u0026#x3C;p\u003e{error}\u0026#x3C;/p\u003e : null}\n      \u0026#x3C;ul\u003e\n        {items.map((item) =\u003e {\n          return \u0026#x3C;li\u003e{item.contents}\u0026#x3C;/li\u003e\n        })}\n      \u0026#x3C;/ul\u003e\n    \u0026#x3C;/div\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこのような形で、ページ遷移時に非同期で何かを取得してくる処理を thunk 無しでも実現することができます。\u003c/p\u003e\n\u003cp\u003eまた、このように非同期処理のロジックを custom hooks に閉じ込めておくことで、別のページで同じ処理が必要になった時に hooks を使い回すことができます\n上の Compnent の例では、useEffect も useFoo の中に入れることで、完全にロジックと Component を分割させることができます。\u003c/p\u003e\n\u003ch2\u003eあとがき\u003c/h2\u003e\n\u003cp\u003eこれはあくまで自分の redux-thunk の使い方なら redux-thunk 使わなくても出来るかなと言う話なので、\nredux-thunk や redux-saga じゃないとこれができないよ！みたいなことがあれば教えてほしいです。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"$L8\",null,{\"title\":\"naturalclar.dev\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"You might not need thunk\"}],[\"$\",\"p\",null,{\"style\":{\"display\":\"block\",\"marginBottom\":\"16px\"},\"children\":\"September 01, 2019\"}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}],[\"$\",\"hr\",null,{\"style\":{\"marginBottom\":\"16px\"}}],[\"$\",\"div\",null,{\"style\":{\"display\":\"flex\",\"alignItems\":\"center\",\"marginBottom\":\"40px\"},\"children\":[[\"$\",\"$Le\",null,{\"src\":\"https://www.github.com/Naturalclar.png\",\"width\":50,\"height\":50,\"alt\":\"Naturalclar (Jesse Katsumata)\",\"style\":{\"marginRight\":\"16px\",\"marginBottom\":0,\"minWidth\":50,\"borderRadius\":\"100%\"}}],[\"$\",\"div\",null,{\"style\":{\"display\":\"flex\",\"flexDirection\":\"column\",\"gap\":\"8px\"},\"children\":[[\"$\",\"p\",null,{\"style\":{\"margin\":0},\"children\":[\"Author: \",[\"$\",\"strong\",null,{\"children\":\"Naturalclar (Jesse Katsumata)\"}]]}],[\"$\",\"p\",null,{\"style\":{\"margin\":0},\"children\":[[\"$\",\"a\",null,{\"href\":\"https://x.com/natural_clar\",\"children\":\"X\"}],\" \",[\"$\",\"a\",null,{\"href\":\"https://www.github.com/Naturalclar\",\"children\":\"Github\"}]]}]]}]]}],[\"$\",\"ul\",null,{\"style\":{\"display\":\"flex\",\"flexWrap\":\"wrap\",\"justifyContent\":\"space-between\",\"listStyle\":\"none\",\"padding\":0},\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"$L9\",null,{\"href\":\"/posts/typescript-allowing-unused-param\",\"rel\":\"prev\",\"children\":[\"← \",\"noUnusedParametersがtrueでも部分的にignoreできる話\"]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L9\",null,{\"href\":\"/posts/chrome-devtool-console\",\"rel\":\"next\",\"children\":[\"Chrome Developer ToolsのConsole\",\" →\"]}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"You might not need thunk | naturalclar.dev\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"\\n状態管理に redux を使っている人は以下の様なことをやりたいことがあるでしょう。\\n\\n- ログイン処理でフォームを Submit した時に API を叩いて、返ってきた Auth 情報を store に保持する。\\n- ページを開いた時に API を叩いて、返ってきた Response を store に保持する。\\n\\nこのような非同期処理の結果を redux に保持することが必要な時にはよく `...\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"Naturalclar (Jesse Katsumata)\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"react, react-native, nextjs, blog\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"Naturalclar (Jesse Katsumata)\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"Naturalclar (Jesse Katsumata)\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:title\",\"content\":\"You might not need thunk | naturalclar.dev\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:description\",\"content\":\"\\n状態管理に redux を使っている人は以下の様なことをやりたいことがあるでしょう。\\n\\n- ログイン処理でフォームを Submit した時に API を叩いて、返ってきた Auth 情報を store に保持する。\\n- ページを開いた時に API を叩いて、返ってきた Response を store に保持する。\\n\\nこのような非同期処理の結果を redux に保持することが必要な時にはよく `...\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:url\",\"content\":\"https://blog.naturalclar.dev/\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:site_name\",\"content\":\"naturalclar.dev\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:image\",\"content\":\"https://blog.naturalclar.dev/twitter-card.png\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:image:alt\",\"content\":\"You might not need thunk\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:creator\",\"content\":\"@natural_clar\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:title\",\"content\":\"You might not need thunk | naturalclar.dev\"}],[\"$\",\"meta\",\"21\",{\"name\":\"twitter:description\",\"content\":\"\\n状態管理に redux を使っている人は以下の様なことをやりたいことがあるでしょう。\\n\\n- ログイン処理でフォームを Submit した時に API を叩いて、返ってきた Auth 情報を store に保持する。\\n- ページを開いた時に API を叩いて、返ってきた Response を store に保持する。\\n\\nこのような非同期処理の結果を redux に保持することが必要な時にはよく `...\"}],[\"$\",\"meta\",\"22\",{\"name\":\"twitter:image\",\"content\":\"https://blog.naturalclar.dev/twitter-card.png\"}]]\n"])</script><script>self.__next_f.push([1,"3:null\n"])</script></body></html>